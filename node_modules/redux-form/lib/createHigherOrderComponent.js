'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _reactRedux = require('react-redux');

var _actions = require('./actions');

var importedActions = _interopRequireWildcard(_actions);

var _getDisplayName = require('./getDisplayName');

var _getDisplayName2 = _interopRequireDefault(_getDisplayName);

var _reducer = require('./reducer');

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _bindActionData = require('./bindActionData');

var _bindActionData2 = _interopRequireDefault(_bindActionData);

var _getValues = require('./getValues');

var _getValues2 = _interopRequireDefault(_getValues);

var _isValid = require('./isValid');

var _isValid2 = _interopRequireDefault(_isValid);

var _readFields = require('./readFields');

var _readFields2 = _interopRequireDefault(_readFields);

var _handleSubmit2 = require('./handleSubmit');

var _handleSubmit3 = _interopRequireDefault(_handleSubmit2);

var _asyncValidation = require('./asyncValidation');

var _asyncValidation2 = _interopRequireDefault(_asyncValidation);

var _eventsSilenceEvents = require('./events/silenceEvents');

var _eventsSilenceEvents2 = _interopRequireDefault(_eventsSilenceEvents);

var _eventsSilenceEvent = require('./events/silenceEvent');

var _eventsSilenceEvent2 = _interopRequireDefault(_eventsSilenceEvent);

var _wrapMapDispatchToProps = require('./wrapMapDispatchToProps');

var _wrapMapDispatchToProps2 = _interopRequireDefault(_wrapMapDispatchToProps);

var _wrapMapStateToProps = require('./wrapMapStateToProps');

var _wrapMapStateToProps2 = _interopRequireDefault(_wrapMapStateToProps);

/**
 * Creates a HOC that knows how to create redux-connected sub-components.
 */
var createHigherOrderComponent = function createHigherOrderComponent(config, isReactNative, React, WrappedComponent, mapStateToProps, mapDispatchToProps) {
  var Component = React.Component;
  var PropTypes = React.PropTypes;

  return function (reduxMountPoint, formName, formKey, getFormState) {
    var ReduxForm = (function (_Component) {
      _inherits(ReduxForm, _Component);

      function ReduxForm(props) {
        _classCallCheck(this, ReduxForm);

        _Component.call(this, props);
        // bind functions
        this.asyncValidate = this.asyncValidate.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.fields = _readFields2['default'](props, {}, this.asyncValidate, isReactNative);
      }

      ReduxForm.prototype.componentWillMount = function componentWillMount() {
        var _props = this.props;
        var initialize = _props.initialize;
        var initialValues = _props.initialValues;

        if (initialValues) {
          initialize(initialValues);
        }
      };

      ReduxForm.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (!_deepEqual2['default'](this.props.fields, nextProps.fields) || !_deepEqual2['default'](this.props.form, nextProps.form)) {
          this.fields = _readFields2['default'](nextProps, this.fields, this.asyncValidate, isReactNative);
        }
        if (!_deepEqual2['default'](this.props.initialValues, nextProps.initialValues)) {
          this.props.initialize(nextProps.initialValues);
        }
      };

      ReduxForm.prototype.componentWillUnmount = function componentWillUnmount() {
        if (config.destroyOnUnmount) {
          this.props.destroy();
        }
      };

      ReduxForm.prototype.asyncValidate = function asyncValidate(name, value) {
        var _this = this;

        var _props2 = this.props;
        var asyncValidate = _props2.asyncValidate;
        var dispatch = _props2.dispatch;
        var fields = _props2.fields;
        var form = _props2.form;
        var startAsyncValidation = _props2.startAsyncValidation;
        var stopAsyncValidation = _props2.stopAsyncValidation;
        var validate = _props2.validate;

        if (asyncValidate) {
          var _ret = (function () {
            var values = _getValues2['default'](fields, form);
            if (name) {
              values[name] = value;
            }
            var syncErrors = validate(values, _this.props);

            // if blur validating, only run async validate if sync validation passes
            if (!name || _isValid2['default'](syncErrors[name])) {
              return {
                v: _asyncValidation2['default'](function () {
                  return asyncValidate(values, dispatch, _this.props);
                }, startAsyncValidation, stopAsyncValidation)
              };
            }
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      };

      ReduxForm.prototype.handleSubmit = function handleSubmit(submitOrEvent) {
        var _this2 = this;

        var _props3 = this.props;
        var onSubmit = _props3.onSubmit;
        var fields = _props3.fields;
        var form = _props3.form;

        var check = function check(submit) {
          if (!submit || typeof submit !== 'function') {
            throw new Error('You must either pass handleSubmit() an onSubmit function or pass onSubmit as a prop');
          }
          return submit;
        };
        var values = _getValues2['default'](fields, form);
        return !submitOrEvent || _eventsSilenceEvent2['default'](submitOrEvent) ?
        // submitOrEvent is an event: fire submit
        _handleSubmit3['default'](check(onSubmit), values, this.props, this.asyncValidate) :
        // submitOrEvent is the submit function: return deferred submit thunk
        _eventsSilenceEvents2['default'](function (event) {
          _eventsSilenceEvent2['default'](event);
          _handleSubmit3['default'](check(submitOrEvent), values, _this2.props, _this2.asyncValidate);
        });
      };

      ReduxForm.prototype.render = function render() {
        var _this3 = this;

        var allFields = this.fields;
        var _props4 = this.props;
        var asyncBlurFields = _props4.asyncBlurFields;
        var blur = _props4.blur;
        var change = _props4.change;
        var destroy = _props4.destroy;
        var focus = _props4.focus;
        var fields = _props4.fields;
        var form = _props4.form;
        var initialValues = _props4.initialValues;
        var initialize = _props4.initialize;
        var onSubmit = _props4.onSubmit;
        var reset = _props4.reset;
        var returnRejectedSubmitPromise = _props4.returnRejectedSubmitPromise;
        var startAsyncValidation = _props4.startAsyncValidation;
        var startSubmit = _props4.startSubmit;
        var stopAsyncValidation = _props4.stopAsyncValidation;
        var stopSubmit = _props4.stopSubmit;
        var submitFailed = _props4.submitFailed;
        var touch = _props4.touch;
        var untouch = _props4.untouch;
        var validate = _props4.validate;

        var passableProps = _objectWithoutProperties(_props4, ['asyncBlurFields', 'blur', 'change', 'destroy', 'focus', 'fields', 'form', 'initialValues', 'initialize', 'onSubmit', 'reset', 'returnRejectedSubmitPromise', 'startAsyncValidation', 'startSubmit', 'stopAsyncValidation', 'stopSubmit', 'submitFailed', 'touch', 'untouch', 'validate']);

        var _allFields$_meta = allFields._meta;
        var allPristine = _allFields$_meta.allPristine;
        var allValid = _allFields$_meta.allValid;
        var errors = _allFields$_meta.errors;
        var formError = _allFields$_meta.formError;
        var values = _allFields$_meta.values;

        return React.createElement(WrappedComponent, _extends({}, passableProps, { // contains dispatch

          // State:
          active: form._active,
          asyncValidating: form._asyncValidating,
          dirty: !allPristine,
          error: formError,
          errors: errors,
          fields: allFields,
          formKey: formKey,
          invalid: !allValid,
          pristine: allPristine,
          submitting: form._submitting,
          submitFailed: form._submitFailed,
          valid: allValid,
          values: values,

          // Actions:
          asyncValidate: _eventsSilenceEvents2['default'](function () {
            return _this3.asyncValidate();
          }),
          // ^ doesn't just pass this.asyncValidate to disallow values passing
          destroyForm: _eventsSilenceEvents2['default'](destroy),
          handleSubmit: this.handleSubmit,
          initializeForm: _eventsSilenceEvents2['default'](initialize),
          resetForm: _eventsSilenceEvents2['default'](reset),
          touch: _eventsSilenceEvents2['default'](function () {
            return touch.apply(undefined, arguments);
          }),
          touchAll: _eventsSilenceEvents2['default'](function () {
            return touch.apply(undefined, fields);
          }),
          untouch: _eventsSilenceEvents2['default'](function () {
            return untouch.apply(undefined, arguments);
          }),
          untouchAll: _eventsSilenceEvents2['default'](function () {
            return untouch.apply(undefined, fields);
          })
        }));
      };

      return ReduxForm;
    })(Component);

    ReduxForm.displayName = 'ReduxForm(' + _getDisplayName2['default'](WrappedComponent) + ')';
    ReduxForm.WrappedComponent = WrappedComponent;
    ReduxForm.propTypes = {
      // props:
      asyncBlurFields: PropTypes.arrayOf(PropTypes.string),
      asyncValidate: PropTypes.func,
      dispatch: PropTypes.func.isRequired,
      fields: PropTypes.arrayOf(PropTypes.string).isRequired,
      form: PropTypes.object,
      initialValues: PropTypes.any,
      onSubmit: PropTypes.func,
      validate: PropTypes.func,
      readonly: PropTypes.bool,
      returnRejectedSubmitPromise: PropTypes.bool,

      // actions:
      blur: PropTypes.func.isRequired,
      change: PropTypes.func.isRequired,
      destroy: PropTypes.func.isRequired,
      focus: PropTypes.func.isRequired,
      initialize: PropTypes.func.isRequired,
      reset: PropTypes.func.isRequired,
      startAsyncValidation: PropTypes.func.isRequired,
      startSubmit: PropTypes.func.isRequired,
      stopAsyncValidation: PropTypes.func.isRequired,
      stopSubmit: PropTypes.func.isRequired,
      submitFailed: PropTypes.func.isRequired,
      touch: PropTypes.func.isRequired,
      untouch: PropTypes.func.isRequired
    };
    ReduxForm.defaultProps = {
      asyncBlurFields: [],
      form: _reducer.initialState,
      readonly: false,
      returnRejectedSubmitPromise: false,
      validate: function validate() {
        return {};
      }
    };

    // bind touch flags to blur and change
    var unboundActions = _extends({}, importedActions, {
      blur: _bindActionData2['default'](importedActions.blur, {
        touch: !!config.touchOnBlur
      }),
      change: _bindActionData2['default'](importedActions.change, {
        touch: !!config.touchOnChange
      })
    });

    // make redux connector with or without form key
    var decorate = formKey !== undefined && formKey !== null ? _reactRedux.connect(_wrapMapStateToProps2['default'](mapStateToProps, function (state) {
      var formState = getFormState(state, reduxMountPoint);
      if (!formState) {
        throw new Error('You need to mount the redux-form reducer at "' + reduxMountPoint + '"');
      }
      return formState && formState[formName] && formState[formName][formKey];
    }), _wrapMapDispatchToProps2['default'](mapDispatchToProps, _bindActionData2['default'](unboundActions, { form: formName, key: formKey }))) : _reactRedux.connect(_wrapMapStateToProps2['default'](mapStateToProps, function (state) {
      var formState = getFormState(state, reduxMountPoint);
      if (!formState) {
        throw new Error('You need to mount the redux-form reducer at "' + reduxMountPoint + '"');
      }
      return formState && formState[formName];
    }), _wrapMapDispatchToProps2['default'](mapDispatchToProps, _bindActionData2['default'](unboundActions, { form: formName })));

    return decorate(ReduxForm);
  };
};

exports['default'] = createHigherOrderComponent;
module.exports = exports['default'];